%{
#include <stdio.h>
#include <string.h>
#include "command.h"
void yyerror(const char *s);
void InitCommand();
int yylex();
int yyparse();
Command* curCommand;
CommandStack cmdStack;
%}

%union {
    char* string_val;
}


/* these tokens are generated by YACC (or bison) and stored in the 'y.tab.h' file, which is included in the lexer file as well. */
%token GREAT NEWLINE GREATGREAT PIPE AMPERSAND LESS GREATAMPERSAND GREATGREATAMPERSAND
%token <string_val> WORD


%type <string_val> cmd_and_args pipe_list arg_list

%%

command_list: 
	| command_list command_line
	;

command_line: 
	pipe_list NEWLINE {
		// Execute command
		Command cmd = {0};
		int res = PopCommand(&cmdStack, &cmd);
		if (res == -1){
			printf("Cound not pop command!\n");
		}
		Execute(&cmd);
		curCommand=NULL;
		PrintPrompt();
	}
	| NEWLINE 
	;

pipe_list:
	 pipe_list PIPE cmd_and_args 
	 | cmd_and_args {
		InitCommand();
		char** argv = Split($1, ':');
		curCommand->argv = argv;		
		PushCommand(&cmdStack, *curCommand);
	 }
	 ;

cmd_and_args:
	WORD arg_list {
		char * tmp = (char *)malloc(strlen($1) + strlen($2) + 1);
		if (strcmp($2, "") == 0)
			tmp = $1;
		else
			sprintf(tmp, "%s:%s", $1, $2);
		$$ = tmp;	
	}
	;

arg_list: {$$="";}
	|  WORD arg_list {
		char * tmp = (char *)malloc(strlen($1) + strlen($2) + 1);
		if (strcmp($2, "") == 0)
			tmp = $1;
		else
			sprintf(tmp, "%s:%s", $1, $2);
		$$ = tmp;
	}
	;



%%

void yyerror(const char *str)
{
        fprintf(stderr,"error: %s\n",str);
}
 
int yywrap()
{
        return 1;
} 

// Allocates a Command on heap and sets the curCommand global variable to point to it
void InitCommand() {
	Command* cmd = malloc(sizeof(Command));
	curCommand = cmd;
}
  
int main()
{
	Command* curCommand = NULL;
	CommandStack cmdStack = {0};
	PrintPrompt();
        return yyparse();
}
