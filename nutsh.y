%{
#include <stdio.h>
#include <string.h>
#include "command.h"
void yyerror(const char *s);
void InitCommand();
int yylex();
int yyparse();
Command* curCommand;
%}

%union {
    char* string_val;
}


/* these tokens are generated by YACC (or bison) and stored in the 'y.tab.h' file, which is included in the lexer file as well. */
%token GREAT NEWLINE GREATGREAT PIPE AMPERSAND LESS GREATAMPERSAND GREATGREATAMPERSAND
%token <string_val> WORD


%type <string_val> cmd_and_args  arg_list

%%

command_list: 
	| command_list command_line
	;

command_line: 
	pipe_list NEWLINE {
		// Execute command
		Execute(curCommand);
		curCommand=NULL;
		PrintPrompt();
	}
	| NEWLINE 
	;

pipe_list:
	pipe_list PIPE cmd_and_args {
		SimpleCommand sCmd = {0};
		char** argv = Split($3, ':');
		sCmd.argv = argv;		
		if(curCommand == NULL){
			InitCommand();
		}
		AppendSimpleCommand(curCommand, sCmd);
	}
	 | cmd_and_args {
		SimpleCommand sCmd = {0};
		char** argv = Split($1, ':');
		sCmd.argv = argv;		
		if(curCommand == NULL){
			InitCommand();
		}
		AppendSimpleCommand(curCommand, sCmd);
	 }
	 ;

cmd_and_args:
	WORD arg_list {
		char * tmp = (char *)malloc(strlen($1) + strlen($2) + 1);
		if (strcmp($2, "") == 0)
			tmp = $1;
		else
			sprintf(tmp, "%s:%s", $1, $2);
		$$ = tmp;	
	}
	;

arg_list: {$$="";}
	|  WORD arg_list {
		char * tmp = (char *)malloc(strlen($1) + strlen($2) + 1);
		if (strcmp($2, "") == 0)
			tmp = $1;
		else
			sprintf(tmp, "%s:%s", $1, $2);
		$$ = tmp;
	}
	;



%%

void yyerror(const char *str)
{
        fprintf(stderr,"error: %s\n",str);
}
 
int yywrap()
{
        return 1;
} 


// Allocates a Command on heap and sets the curCommand global variable to point to it
void InitCommand(){
	Command* cmd = malloc(sizeof(Command));
	curCommand = cmd;
}

// Allocates a SimpleCommand on heap and returns it
SimpleCommand* InitSimpleCommand(){
	SimpleCommand* cmd = malloc(sizeof(SimpleCommand));
	return cmd;
}

  
int main()
{
	Command* curCommand = NULL;
	PrintPrompt();
        return yyparse();
}
